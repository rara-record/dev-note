# TDD

## 학습 키워드
- TDD란
- Jest
- Describe - Context - It 패턴
- 단위테스트란
- TDD에서 중복을 제거한다는 게 어떤 의미인가

## 좋은 테스트 원칙
테스트 코드를 먼저 작성하여, 구현보다 인터페이스와 스펙을 먼저 정의하면서 개발을 진행하는 방식을 말한다.
1. Red
2. Green
3. Refactor: 제대로 작동하는 클린코드. 동작은 바뀌지 않고
설계는 계속해서 바뀌는 것.

의도를 드러내면 저절로 중복이 드러나는 경우가 있어서,
모아서 처리할 수 있다.

### 훈련방법

- 구현보다 인터페이스와 스펙을 먼저 정의하면서 개발을 진행하는 방식. 
- 막연하게 하는 것이 아니라, 기대값과 유지보수를 생각하면서 작성한다.
- 지나치게 내부 구현 사항을 테스트 하지 말것. 
- 재사용성을 높이기 (테스트 유틸리티)
- 배포용 코드와 철저히 분리한다.
- 테스트 코드는 어느정도 문서화라는 것을 잊지 말기

## 좋은 테스트의 구조 Given-When-Then 
- Given : 준비
- When : 실행
- Then : 결과
테스트 코드 템플릿.
> 700W 전자렌지를 준비해서 3분만 돌리면 완성!

코드로 보기
```
# Given : 준비, ( ~ 하고, ~ 할때 )
stove = Stove.new(700.watts)

# When :  실행,  (~ 하면 )
food = stove.cook(3.minutes)

# Then ~ : 결과값 확인,  (가 된다, ~를 한다.)
assert food.complete?
```

### 무엇을 테스트 해야 할지 모를 때의 법칙
테스트의 범위

**BICEP**
1. 모든 코너 케이스에 대해 테스트 하기 (Boundary conditions)
> 잘못된 포맷의 인풋, 특수문자, null, 잘못 된 이메일, 작은 숫자, 중복, 순서가 맞지 않을 때 등등. 
2. 역관계를 적용해서 결과값을 확인하기 (Inverse relationship)
> 일관성을 유지. (덧셈은 뺄셈, 추가는 제거)

> ex) 5+5 테스트 후, 10에서 5를 뺴보기. 학생을 추가해서 배열에 추가하면 
> 반대로 그 학생을 제거한 후 배열을 확인하기. (Cross-check)

3. 다른 수단을 이용해서 결과값이 맞는지 확인
> 여러가지를 이용해서 결과값을 확인한다.

> ex) 추가 된 과일 == 전체과일 - 예전의 과일 갯수
>
> A 알고리즘 == B 알고리즘

4. 예상할 수 있는 모든 에러 케이스에 대해 통과하는지 (Error conditions)
> 네트워크 에러, 메모리 부족, ...

5. 성능 확인은 테스트를 통해 정확한 수치로 확인한다. (Performance)
> 성능 개선의 척도와 확인도 데이터를 통해 확인한다.

### 테스트의 조건
**CORRECT** 
1. Conformance 
> 특정 포맷을 준수: 전화 번호, 이메일, 아이디..
2. Ordering
> 순서 조건 확인하기 
3. Range
> 숫자의 범위 : 제한된 범위보다 작거나 큰 경우
4. Reference 
> 외부 의존성 유무, 특정한 조건의 유무, 가정하는 조건에 반할 떄

> ex) B함수 호출 시 A함수를 먼저 실행해야 하는 경우, A함수가 먼저 실행되지 않을 경우에는 어떻게 할 것인지.
5. Existence 
> 값이 존재 하지 않을 때
> null, undefined, '', 0
6. Cardinality
> 0-1-N의 법칙
>
> 하나도 없을 때, 하나만 있을 때, 여러개 있을때
7. Time
> 상대, 절대 동시의 일들
> 순서가 맞지 않은 경우, 소비한 시간, 지역 시간


## TDD(테스트 주도 개발)
테스트 코드를 먼저 작성하는 개발 방법론은 테스트 주도 개발(Test-Driven Development, TDD)로 많이 불린다.
좋은 테스트의 특징 중 Timely, 테스트는 적시에 즉, 테스트 하려는 실제 코드를 구현하기 직전에 구현해야 한다는 말이 있다.
왜 그럴까?
TDD의 궁극적인 목표는, 작동하는 깔끔한 코드를 작성하는 것에 있다.
현실적인 측면에서, 프로덕션 코드를 먼저 작성 한 후 진행하려면 너무 귀찮다는.. 

먼저,
1. 실패 테스트 부터 작성한다
2. 순차적으로 실패하는 테스트 작성 후, 오직 실패 할 경우에만 새로운 코드를 작성한다.
3. 중복된 코드는 제거한다.

### 테스트 코드 개발 순서
1. 실패하는 작은 단위 테스트를 작성한다.
2. 빨리 통과하기 위해 프로덕션 코드를 작성한다 (정답이 아닌 가짜 구현도 괜찮다)
3. 그 다음의 테스트 코드를 작성한다. 실패 테스트가 없을 경우에만 성공 테스트를 작성한다
4. 새로운 테스트를 통과하기 위해 프로덕션 코드를 추가 또는 수정한다
5. 1~4단계를 반복하여, 실패/성공의 모든 테스트 케이스를 작성한다
6. 개발 된 코드들에 대해 모든 중복을 제거하며 리팩토링 한다.


## Jest
자바스크립트 환경에서는 jest를 다 사용할 수 있다.

[jest 공식문서](https://mulder21c.github.io/jest/docs/en/next/getting-started.html)
### 특징
1. 복잡한 설정이 필요 없다
2. snapshots test를 지원한다
3. 단위테스트와는 별개이다. 

### Jest에서 typescript 사용하도록 파일 추가
```
jset.config.js
```
```javascript
module.exports = {
	testEnvironment: 'jsdom',
	setupFilesAfterEnv: [
		'@testing-library/jest-dom/extend-expect',
	],
	transform: {
		'^.+\\.(t|j)sx?$': ['@swc/jest', {
			jsc: {
				parser: {
					syntax: 'typescript',	
					jsx: true,
					decorators: true,
				},
				transform: {	
					react: {
						runtime: 'automatic',
					},
				},
			},
		}],
	},
};
```

Jest 실행
```
npx jest

npx jest --watchAll
```

### 테스트 코드를 작성하는 방법
1. test 함수로 개별 테스트를 나열한다.
```jset
// 함수 정의
const add = (x: number, y: number): number => {
  return 0;
}


test('add 함수는 두 훗자를 더한다.' () => {
  expect(add(1, 2)).toBe(3);
});


expect() : 기대 함수
toBe() : 결과값
beforeEach : 테스트 함수가 실행되기 전 호출 
afterEach : 테스트 함수가 끝나면 호출
```

2. BDD 스타일로 대상과 행위를 명확히 드러낸다.
```jset
describe('add', () => { 
  it('add 함수는 두 숫자를 더해서 리턴한다', () => {
    expect(add(1, 2))
      .toBe(3);
  });
});

add // 주어
it // 설명
add 함수는 ~ it ~한다.
```


## 리액트 테스트 라이브러리
리액트 컴포넌트를 사용자 입장에 가깝게 테스트할 수 있는 도구이다.


